const fs = require('fs');
const path = require('path');
const MarkdownIt = require('markdown-it'),
  md = new MarkdownIt();
const juice = require('juice');
const lib = require('../src/lib');
// let source = fs.readFileSync(path.join(__dirname, '../note', 'testTags.md'), 'utf8');
// let source = "# Koa 快速开始\n\n记录下快速搭建一个 koa 网站的步骤。没找到官方脚手架。。。嗯，那就自己搭一个，参考下其他人的脚手架。\n\n## 安装必备依赖\n\n```json\n\"dependencies\": {\n    \"babel-core\": \"^6.18.2\",\n    \"babel-polyfill\": \"^6.16.0\",\n    \"babel-preset-es2015-node6\": \"^0.4.0\",\n    \"babel-preset-stage-3\": \"^6.17.0\",\n    \"koa\": \"^2.0.0\"\n}\n```\n必备依赖就是运行起一个 koa 应用所需最少的依赖。\n> 最少依赖其实只有 koa，但是为了提前使用 async 函数，所以安装 babel 来进行转换。\n\n## 能够运行的网站\n\n安装依赖后，就可以实现我们的网站了，先实现一个最简单的：\n```javascript\n// index.js\n// 导入 koa 依赖\nconst Koa = require('koa');\n\n// 创建一个Koa对象表示web app本身:\nconst app = new Koa();\n\n// 对于任何请求，app将调用该异步函数处理请求：\napp.use(async (ctx, next) => {\n    await next();\n    ctx.response.type = 'text/html';\n    ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n\n// 在端口3000监听:\napp.listen(3000);\nconsole.log('app started at port 3000...');\n```\n这些代码表示将会开启一个端口为`3000`的服务器，且只返回 `Hello, koa2!`。\n\n当然，到这为止只用上了 koa 这个依赖，所以直接运行会报错，因为语法无法识别，所以要用上 babel了，新建一个文件：\n```javascript\n// start.js\nlet register = require('babel-core/register');\n\nregister({\n    presets: ['stage-3']\n});\n\nrequire('./index.js');\n```\n\n这个文件作为了整个应用的路口。\n```bash\nnode start.js\n```\n开启服务，控制台打印出\n```bash\napp started at port 3000...\n```\n然后可以在浏览器地址栏输入`127.0.0.1:3000`访问，页面不出意外会显示`Hello, koa2!`。\n\n## 路由控制\n网站肯定需要根据用户输入的不同 url 显示出不同的页面。每次请求，async 函数能够获取到两个参数，`ctx`和`next`，重点关注 `ctx`，这个对象里面保存了请求的 url，通过对 url 判断，给出不同的处理函数。\n\n```javascript\napp.use(async (ctx, next) => {\n    if(ctx.request.url === '/') {\n        ctx.response.type = 'text/html';\n        ctx.response.body = '<h1>Hello, koa2!</h1>';\n    }\n    else if(ctx.request.url === '/person') {\n        ctx.response.type = 'text/html';\n        ctx.response.body = '<h1>Person Page</h1>';\n    }else {\n        ctx.response.type = 'text/html';\n        ctx.response.body = '<h1>Not Found</h1>';\n    }\n});\n```\n\n重新运行后可以访问`/person`页面，随便输入一个地址也不再总是显示`Hello, koa2!`。\n\n为了简化代码，使用`koa-router`这个中间件。\n\n```bash\nnpm install --save koa-router@next\n```\n\n改写`index.js`\n```javascript\n// index.js\n// 导入 koa 依赖\nconst Koa = require('koa');\n// 路由中间件koa-router 暴露出来的是一个函数\nconst router = require('koa-router')();\n\n// 创建一个Koa对象表示web app本身:\nconst app = new Koa();\n\n// 配置路由\nrouter.get('/', async (ctx, next) => {\n    ctx.response.body = '<h1>Index</h1>';\n});\n\nrouter.get('/hello/:name', async (ctx, next) => {\n    var name = ctx.params.name;\n    ctx.response.body = `<h1>Hello, ${name}!</h1>`;\n});\n\n// 注册配置好的路由\napp.use(router.routes());\n\n// 在端口3000监听:\napp.listen(3000);\nconsole.log('app started at port 3000...');\n```\n\n然后重启服务器，正确响应我们的请求。\n\n## 调整目录结构\n\n“处理用户请求，根据用户请求给出不同的数据”，这就是 MVC 中的 C 需要做的事情，所以可以把配置路由抽取出来。\n\n```javascript\n// controllers/index.js\nlet index = (ctx, next) => {\n    console.log(ctx)\n    ctx.response.body = '<h1>Index</h1>';\n}\n\nmodule.exports = {\n    'GET /': index\n}\n```\n```javascript\n// controllers/hello.js\nlet hello = async (ctx, next) => {\n    var name = ctx.params.name;\n    ctx.response.body = `<h1>Hello, ${name}!</h1>`;\n}\n\nmodule.exports = {\n    'GET /hello/:name': hello\n}\n```\n\n最后封装成自己的中间件：\n```javascript\n// middlewares/controller\nconst fs = require('fs')\nconst path = require('path')\n/*\n    controller 中间件的作用，就是\n    1、获取 controllers 文件夹下的每一个 js 文件\n    2、导入得到的每一个 js 文件，得到的是一个对象，对对象进行处理，注册到 router 上\n    从这一段描述中，就可以得到三个函数，\n*/\n// 第一个函数，读取 controllers 文件夹下的文件\nfunction getControllers(dir) {\n    let files = fs.readdirSync(path.join(__dirname, '../controllers'))\n    return controllers = files.filter(file => {\n        return file.endsWith('.js')\n    })\n}\n// 第二个函数\nfunction addMapping(router, obj) {\n    for(let url in obj) {\n        if (url.startsWith('GET ')) {\n            // 如果url类似\"GET xxx\":\n            let uri = url.substring(4);\n            router.get(uri, obj[url]);\n            console.log(`register URL mapping: GET ${path}`);\n        } else if (url.startsWith('POST ')) {\n            // 如果url类似\"GET xxx\":\n            let uri = url.substring(5);\n            router.post(uri, obj[url]);\n            console.log(`register URL mapping: POST ${path}`);\n        } else {\n            // 无效的URL:\n            console.log(`invalid URL: ${url}`);\n        }\n    }\n}\n\n// 最外层的大函数\nfunction addControllers(router, dir) {\n    // 将每一个 controller 导入\n    let controllers = getControllers(dir)\n    controllers.forEach(controller => {\n        console.log(`process controller: ${controller}...`)\n        // 获得每一个 js 文件导出的对象\n        let obj = require(path.join(__dirname, '../controllers', controller))\n        // 根据键值对进行处理\n        addMapping(router, obj)\n    })\n}\n\nmodule.exports = function (dir) {\n    let controllers_dir = dir || 'controllers',\n        router = require('koa-router')();\n    addControllers(router, controllers_dir);\n    return router.routes();\n};\n```\n\n然后就可以用自己定义的中间件了：\n```javascript\n// 导入 koa 依赖\nconst Koa = require('koa');\n// 路由中间件koa-router 暴露出来的是一个函数\nconst router = require('koa-router')();\n\n// 创建一个Koa对象表示web app本身:\nconst app = new Koa();\n\n// 控制器中间件\nconst controller = require('./middlewares/controller')\n\n// 注册配置好的路由\napp.use(controller());\n\n// 在端口3000监听:\napp.listen(3000);\nconsole.log('app started at port 3000...');\n```\n\n想要增加一个新的页面，就直接在 controllers 里面写新文件就可以了。\n\n> 其实这里可以更优化一下，直接把文件名作为 url，就不用自己手写`GET /`这种东西了。这样改造后，就更像 PHP 了。\n\n\n"
let source = "# Koa 快速开始"
const noteInfo = lib.getTags(source, md);
// console.log(noteInfo);
// return;
let html = md.render(noteInfo.source);
console.log(html);


let style = fs.readFileSync(path.join(__dirname, '../src/themes', 'github_markdown.css'), 'utf8');
let content = juice.inlineContent(html, style);
// 生成 html
fs.writeFileSync('template.html', content, 'utf8');